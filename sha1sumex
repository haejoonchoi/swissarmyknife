#!/usr/bin/env python
# sha1sumex
# An improved sha1sum
# https://github.com/rcook/swissarmyknife

import argparse
import os
import sys

from shared import *

def run_generate(args):
    list_path = os.path.abspath(args.list_file)
    start_dir = os.path.abspath(args.start_dir)
    with open(list_path, "wt") as f:
        for base_dir, subdir_names, file_names in os.walk(start_dir):
            subdir_names.sort()
            for file_name in sorted(file_names):
                full_path = os.path.join(base_dir, file_name)
                rel_path = os.path.relpath(full_path, start_dir)
                sig = compute_sha1(full_path, partial=args.partial, include_file_size=False)
                f.write("{} {}\n".format(sig, rel_path))
                if args.progress:
                    print("{} {}".format(sig, rel_path))

def run_verify(args):
    list_path = os.path.abspath(args.list_file)
    start_dir = os.path.abspath(args.start_dir)
    match_count = 0
    mismatch_count = 0
    with open(list_path, "rt") as f:
        for _, line in enumerate(f):
            expected_sig, f = line.strip().split(" ", 1)
            full_path = os.path.join(start_dir, f)
            if args.progress:
                print(full_path)

            sig = compute_sha1(full_path, partial=args.partial, include_file_size=False)
            if sig == expected_sig:
                match_count += 1
            else:
                mismatch_count += 1
                print("Signature mismatch: {}".format(full_path))

    if mismatch_count == 0:
        print("OK: All signatures match ({:,} matches, {:,} mismatches)".format(match_count, mismatch_count))
    else:
        print("Failure: some signatures did not match ({:,} matches, {:,} mismatches)".format(match_count, mismatch_count))

def main(argv=None):
    if argv is None:
        argv = sys.argv[1:]

    parser = argparse.ArgumentParser(
        description="An improved sha1sum",
        epilog=GITHUB_URL)

    add_switch_with_inverse(
        parser,
        "partial",
        default=False,
        help="compute partial (short) signatures",
        inverse_help="compute full (long) signatures")
    add_switch_with_inverse(
        parser,
        "progress",
        default=True,
        help="show files as they are processed",
        inverse_help="do not show files as they are processed")

    subparsers = parser.add_subparsers()

    generate_parser = subparsers.add_parser("generate", help="generate checksum file")
    generate_parser.add_argument("list_file", metavar="LISTFILE", type=os.path.abspath)
    generate_parser.add_argument("start_dir", metavar="STARTDIR", type=os.path.abspath)
    generate_parser.set_defaults(func=run_generate)

    verify_parser = subparsers.add_parser("verify", help="verify files in checksum file")
    verify_parser.add_argument("list_file", metavar="LISTFILE", type=os.path.abspath)
    verify_parser.add_argument("start_dir", metavar="STARTDIR", type=os.path.abspath)
    verify_parser.set_defaults(func=run_verify)

    args = parser.parse_args(argv)
    args.func(args)

if __name__ == "__main__":
    main()
